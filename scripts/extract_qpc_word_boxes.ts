/**
 * SVG Word Bounding Box Extraction Script
 * 
 * Usage (run locally after git pull):
 *   npx ts-node scripts/extract_qpc_word_boxes.ts
 * 
 * Prerequisites:
 *   npm install playwright fs-extra
 *   npx playwright install chromium
 * 
 * Input:
 *   - public/qpc-svg/page-001.svg ... page-604.svg
 *   - src/data/mushaf-layout/pageWords.json (generated by generate_page_words.ts)
 * 
 * Output:
 *   - src/data/qpc_word_boxes/page-001.json ... page-604.json
 */

import fs from "fs-extra";
import path from "path";
import { chromium } from "playwright";

const PAGES = 604;
const LINE_Y_THRESHOLD = 0.01; // 1% of page height for line grouping
const WORD_GAP_THRESHOLD = 0.003; // 0.3% of page width for word merging

function pad3(n: number): string {
  return String(n).padStart(3, "0");
}

interface RawBox {
  x: number;
  y: number;
  w: number;
  h: number;
  tag: string;
}

interface LayoutWord {
  key: string;
  text: string;
}

interface PageLayout {
  page: number;
  words: LayoutWord[];
}

/**
 * Group raw boxes into lines based on Y proximity,
 * then sort RTL within each line
 */
function sortReadingOrder(boxes: RawBox[]): RawBox[] {
  if (boxes.length === 0) return [];

  // Sort by Y first
  const sorted = [...boxes].sort((a, b) => a.y - b.y);

  // Group into lines
  const lines: RawBox[][] = [];
  let currentLine: RawBox[] = [sorted[0]];

  for (let i = 1; i < sorted.length; i++) {
    const prevY = currentLine[0].y;
    if (Math.abs(sorted[i].y - prevY) < LINE_Y_THRESHOLD) {
      currentLine.push(sorted[i]);
    } else {
      lines.push(currentLine);
      currentLine = [sorted[i]];
    }
  }
  lines.push(currentLine);

  // Sort each line RTL (descending X)
  for (const line of lines) {
    line.sort((a, b) => b.x - a.x);
  }

  return lines.flat();
}

/**
 * Merge small adjacent boxes within the same line into word-level boxes
 */
function mergeIntoWords(boxes: RawBox[]): RawBox[] {
  if (boxes.length === 0) return [];

  const sorted = [...boxes].sort((a, b) => a.y - b.y);
  const lines: RawBox[][] = [];
  let currentLine: RawBox[] = [sorted[0]];

  for (let i = 1; i < sorted.length; i++) {
    if (Math.abs(sorted[i].y - currentLine[0].y) < LINE_Y_THRESHOLD) {
      currentLine.push(sorted[i]);
    } else {
      lines.push(currentLine);
      currentLine = [sorted[i]];
    }
  }
  lines.push(currentLine);

  const merged: RawBox[] = [];

  for (const line of lines) {
    // Sort RTL within line
    line.sort((a, b) => b.x - a.x);

    let group: RawBox = { ...line[0] };

    for (let i = 1; i < line.length; i++) {
      const curr = line[i];
      const groupRight = group.x + group.w;
      const currRight = curr.x + curr.w;

      // Check if gap between this box and the group is small enough to merge
      const gap = Math.abs(curr.x - groupRight);
      if (gap < WORD_GAP_THRESHOLD) {
        // Merge: expand group to include curr
        const minX = Math.min(group.x, curr.x);
        const maxX = Math.max(groupRight, currRight);
        const minY = Math.min(group.y, curr.y);
        const maxY = Math.max(group.y + group.h, curr.y + curr.h);
        group = {
          x: minX,
          y: minY,
          w: maxX - minX,
          h: maxY - minY,
          tag: "merged",
        };
      } else {
        merged.push(group);
        group = { ...curr };
      }
    }
    merged.push(group);
  }

  return sortReadingOrder(merged);
}

async function main() {
  const browser = await chromium.launch();
  const page = await browser.newPage();

  const svgDir = path.resolve("public/qpc-svg");
  const outDir = path.resolve("src/data/qpc_word_boxes");
  await fs.ensureDir(outDir);

  // Load word layout
  const layoutPath = path.resolve("src/data/mushaf-layout/pageWords.json");
  if (!(await fs.pathExists(layoutPath))) {
    console.error(`❌ Missing layout file: ${layoutPath}`);
    console.error("   Run 'npx ts-node scripts/generate_page_words.ts' first");
    process.exit(1);
  }

  const layout: PageLayout[] = await fs.readJson(layoutPath);
  const layoutByPage = new Map(layout.map((p) => [p.page, p.words]));

  let successCount = 0;
  let failCount = 0;
  let mismatchCount = 0;

  for (let pno = 1; pno <= PAGES; pno++) {
    const fname = `page-${pad3(pno)}.svg`;
    const fpath = path.join(svgDir, fname);

    if (!(await fs.pathExists(fpath))) {
      console.warn(`⚠️ Missing SVG: ${fname}`);
      failCount++;
      continue;
    }

    const svg = await fs.readFile(fpath, "utf8");
    await page.setContent(`<!DOCTYPE html><html><body>${svg}</body></html>`, {
      waitUntil: "load",
    });

    const result = await page.evaluate(() => {
      const svgEl = document.querySelector("svg");
      if (!svgEl) throw new Error("No <svg> found");

      // Parse viewBox
      const vb = svgEl.getAttribute("viewBox");
      let vw = 0,
        vh = 0;
      if (vb) {
        const parts = vb.trim().split(/\s+/).map(Number);
        vw = parts[2];
        vh = parts[3];
      } else {
        vw = (svgEl as any).width?.baseVal?.value || 0;
        vh = (svgEl as any).height?.baseVal?.value || 0;
      }

      // Collect measurable elements
      // Prefer <g> groups (often represent word groups in QPC SVGs)
      let nodes: Element[];
      const groups = Array.from(svgEl.querySelectorAll("g[id]"));
      if (groups.length > 10) {
        nodes = groups;
      } else {
        // Fallback: collect text and path elements
        nodes = Array.from(svgEl.querySelectorAll("text, path")).filter(
          (n) => {
            try {
              const b = (n as SVGGraphicsElement).getBBox();
              // Filter out background/frame elements (too large)
              return b.width / vw < 0.5 && b.height / vh < 0.3;
            } catch {
              return false;
            }
          }
        );
      }

      const boxes = nodes
        .map((n) => {
          try {
            const b = (n as SVGGraphicsElement).getBBox();
            if (!vw || !vh) return null;
            // Skip tiny invisible elements
            if (b.width < 1 && b.height < 1) return null;
            return {
              x: b.x / vw,
              y: b.y / vh,
              w: b.width / vw,
              h: b.height / vh,
              tag: n.tagName.toLowerCase(),
            };
          } catch {
            return null;
          }
        })
        .filter(Boolean);

      return { vw, vh, boxes };
    });

    const rawBoxes = result.boxes as RawBox[];

    // Sort in reading order
    let orderedBoxes = sortReadingOrder(rawBoxes);

    const words = layoutByPage.get(pno) || [];

    // If box count doesn't match word count, try merging
    if (orderedBoxes.length !== words.length && rawBoxes.length > words.length) {
      orderedBoxes = mergeIntoWords(rawBoxes);
    }

    const minLen = Math.min(words.length, orderedBoxes.length);

    if (words.length !== orderedBoxes.length) {
      console.warn(
        `⚠️ Page ${pno}: words=${words.length} boxes=${orderedBoxes.length} (using ${minLen})`
      );
      mismatchCount++;
    }

    const out = {
      page: pno,
      viewBox: { w: result.vw, h: result.vh },
      words: Array.from({ length: minLen }).map((_, i) => ({
        key: words[i]?.key ?? `p${pno}-i${i}`,
        text: words[i]?.text ?? "",
        box: {
          x: Math.round(orderedBoxes[i].x * 10000) / 10000,
          y: Math.round(orderedBoxes[i].y * 10000) / 10000,
          w: Math.round(orderedBoxes[i].w * 10000) / 10000,
          h: Math.round(orderedBoxes[i].h * 10000) / 10000,
        },
      })),
      debug: {
        wordsCount: words.length,
        boxesCount: rawBoxes.length,
      },
    };

    await fs.writeJson(path.join(outDir, `page-${pad3(pno)}.json`), out, {
      spaces: 2,
    });
    successCount++;

    if (pno % 50 === 0) {
      console.log(`✅ Progress: ${pno}/${PAGES}`);
    }
  }

  await browser.close();

  console.log("\n=== Extraction Complete ===");
  console.log(`✅ Success: ${successCount}`);
  console.log(`❌ Failed (missing SVG): ${failCount}`);
  console.log(`⚠️ Mismatched: ${mismatchCount}`);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
